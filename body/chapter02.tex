%%==================================================
%% chapter02.tex for SJTU Master Thesis
%% based on CASthesis
%% modified by wei.jianwen@gmail.com
%% Encoding: UTF-8
%%==================================================

\chapter{背景介绍}
\label{chap:background}

\section{系统虚拟化技术的演化}

系统虚拟化毫无疑问是推动当前火热云计算大潮的关键技术之一。随着x86处理器凭借高速增长的处理能力和相对低廉的价格获得市场的广泛认可，x86平台上的系统虚拟化技术在近20年内取得了长足发展，学术界和工业界中都涌现出了一批富有影响力的系统虚拟化产品，如Bochs、Qemu、Xen、VMware、KVM等。

系统虚拟化是一种资源管理技术，其对真实计算机上的处理器资源、内存资源、存储资源等进行分割并赋予虚拟机，让这些用软件实现抽象出来的虚拟机可以像真实机器一样运行程序。然而，x86处理器的设计初衷并没有将系统虚拟化考虑在内，当时在大型主机上普遍适用的``陷入并模拟''（Trap-and-Emulate）虚拟化策略在x86体系结构上未能奏效。这是因为如果按照``陷入并模拟''策略让x86虚拟机在较低权限级别运行，某些敏感x86指令会默默地执行失败而不会产生到虚拟机监控器的陷入，例如POPF，这便让虚拟机监控器失去了模拟这些敏感指令行为的机会。而Intel出于x86平台的向后兼容性考虑，不可能去改变已发布x86指令集的行为，这个困境在很长一段时间里阻碍了x86平台系统虚拟化的发展。

虽然存在不小的困境，但x86平台上的系统虚拟化还不至于无路可循。一种简单粗暴的解决方法便是``模拟执行''。具体而言，便是分配一个足够大的数组当作虚拟机的内存，根据x86指令集规范，编写一个包含众多case分支的switch语句，获取当前要执行的指令，严格按照指令集规范说明模拟执行。以上``模拟执行''的方法固然可行，但效率不敢恭维，这种虚拟机至少要比真实机器慢上一个数量级。此外，所谓的动态类型语言，如Python、PHP、Ruby，在被编译成中间代码后，大多也是遵循了这种``模拟执行''的方法，因此执行速度相比于编译型语言快不起来。著名的x86模拟器Bochs便是采用了这种``模拟执行''方法，虽然速度慢，但是兼容性良好，而且不容易出现安全漏洞。

除去``模拟执行''，二进制翻译技术也能用于解决x86平台上的系统虚拟化困境，且具备性能上的优势。如今Java、.NET、JavaScript等语言使用的JIT（Just-In-Time）技术也是类似的套路。不能因为指令翻译难实现就因噎废食，一个运行上亿次的for循环，其中如果都是加减之类的数学运算操作，翻译成机器码在处理器上直接执行，肯定比``模拟执行''要快得多。应用到系统虚拟化领域时，在二进制翻译前面，要加上``动态''两个字，也就是在虚拟机执行过程中，碰到能翻译的普通指令区块就翻译成目标架构的机器码直接执行，并缓存起来以便后续重复执行，碰到不能直接翻译的特殊指令区块（某些关乎处理器全局状态的敏感指令，例如更改页表寄存器值的MOV \%CR3指令）就陷入到虚拟机监控器中或调用虚拟机监控器提供的接口，让虚拟机监控器模拟执行敏感指令，接着再继续对后面的虚拟机代码进行翻译。

VMware的工程师们在1998年首先实现了基于动态二进制翻译（Dynamic Binary Translation）的虚拟机监控器，成功在x86平台上实现了系统虚拟化，并推出了VMware Workstation、VMware ESX等商业化产品。Fabrice Bellard完成的Qemu实现原理与上述类似，不过Qemu还支持在x86平台上模拟ARM、MIPS、SPARC、PowerPC等多种处理器架构。VMware针对动态二进制翻译还额外提出了众多功能和细节上的优化，这使得其商业化产品性能良好。VMware在x86系统虚拟化领域的创举，也复苏了研究人员和硬件厂商重新发掘这个领域的热情。

动态二进制翻译虽然已经比``模拟执行''快了许多，但由于为了让每条敏感指令得到模拟执行执行流都要往虚拟机管理器绕一圈（而事实上在大多数情况下执行多条敏感指令仅仅是为了完成某个单一目的，如在使用了PAE分页机制的32位操作系统中修改页表项需要两条MOV指令），这使得虚拟机离真实机器的性能仍然有一定差距。为了提升虚拟机的运行性能，研究人员想到了让虚拟机操作系统辅助配合，即为所谓的``半虚拟化''（Para-virtualization）。``Para''前缀是``with''、``alongside''的意思，也就是说虚拟机与虚拟化层不再是严格的上下级关系，而是互信合作的关系。虚拟机操作系统知道自己正处在虚拟化层之上运行，虚拟化层也要在一定程度上信任虚拟机操作系统。Xen在初始阶段便是一个只支持半虚拟化的虚拟化平台，为x86系统虚拟化领域开启了新的篇章。

既然动态二进制翻译的难点和性能瓶颈在于模拟执行那些各式各样的敏感指令，我们能不能修改虚拟机的操作系统内核，把那些敏感指令改得``好看''一些，即对虚拟化更友好？以上便是半虚拟化技术的中心思想。毕竟在大多数情况下，我们并不需要对虚拟机刻意``隐瞒'' 虚拟化层的存在，而是要在虚拟机之间提供必要的隔离，同时又不造成太多的性能开销。

采用半虚拟化的虚拟机操作系统内核需要经过特殊修改，将原先由敏感指令构成的操作改为对虚拟化层功能接口的调用，即超调用（Hypercall）。在现代操作系统中，由于这些体系结构相关的敏感操作实现都被封装起来了（例如Linux内核源码树中的arch/目录），对比动态二进制翻译需要考虑到各种边界情况，半虚拟化对虚拟机操作系统内核源码的修改就显得要简单一些了。相比于使用了动态二进制翻译的全虚拟化（Full-virtualization），半虚拟化是牺牲了通用性来换取性能，因为任何操作系统都可以无修改地运行在全虚拟化平台上，而每个半虚拟化的操作系统内核都要经过人工仔细修改，且要以能获取其源码为前提。

同样的功能，依靠专用硬件实现几乎总是比软件实现性能更好，这几乎已经成为了一条金科玉律。为了顺应市场对于高性能x86系统虚拟化方案的强烈愿求，Intel和AMD在2005年几乎于相同的时间推出了x86硬件辅助虚拟化（Hardware-assisted Virtualization）解决方案。Intel的解决方案叫做Vanderpool或VMX（Virtual Machine Extension），AMD的解决方案被称为（Secure Virtual Machine）。

在硬件上帮助软件系统实现以前难以完美解决的方案并不是一个新概念。早在1974年，Popek和Goldberg便在``Formal requirements for virtualizable third generation architectures''著名论文中提及了可虚拟化体系结构必须满足的三个必要条件：1）虚拟机监控器提供了与真实机器一模一样的虚拟环境；2）运行在虚拟机里的程序在最坏情况下也比物理机慢得不多；3）虚拟机监控器能够完全控制所有的系统资源；3a）虚拟机里的程序不能访问未分配给它的资源，3b）在某些情况下，虚拟机监控器能够回收已经分配给虚拟机的资源。早期的x86指令架构不满足上述条件，因而需要虚拟机监控器进行复杂的动态二进制翻译。既然动态二进制翻译的主要工作在于捕获虚拟机执行中的敏感指令，硬件辅助虚拟化中处理器最重要的角色便是捕获这些关键事件并将其交由虚拟机监控器处理。

为了维持对早期x86程序的兼容性，硬件辅助虚拟化在x86体系结构原有的四个执行特权级（Ring）基础上，增加了一个专供虚拟机监控器使用的与原先特权级别正交的根模式（Root mode），而虚拟机中的操作系统和应用程序处于独立的非根模式（Non-root mode）运行。这样一来，尽管虚拟机操作系统运行在Ring 0，其执行敏感指令时仍然会触发异常并被处理器自动捕获，从而陷入到位于根模式的虚拟机监控器中，待到虚拟机监控器完成处理后再使用VMLAUNCH或VMRESUME指令让执行流返回虚拟机。

下一节将对硬件辅助虚拟化技术进行详细阐述。

\section{硬件辅助虚拟化技术}

\section{本章小结}

