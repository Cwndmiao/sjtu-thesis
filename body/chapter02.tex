%%==================================================
%% chapter02.tex for SJTU Master Thesis
%% based on CASthesis
%% modified by wei.jianwen@gmail.com
%% Encoding: UTF-8
%%==================================================

\chapter{背景介绍}
\label{chap:background}

\section{系统虚拟化技术的演化}

系统虚拟化毫无疑问是推动当前火热云计算大潮的关键技术之一。随着x86处理器凭借高速增长的处理能力和相对低廉的价格获得市场的广泛认可，x86平台上的系统虚拟化技术在近20年内取得了长足发展，学术界和工业界中都涌现出了一批富有影响力的系统虚拟化产品，如Bochs、Qemu、Xen、VMware、KVM等。

系统虚拟化是一种资源管理技术，其对真实计算机上的处理器资源、内存资源、存储资源等进行分割并赋予虚拟机，让这些用软件实现抽象出来的虚拟机可以像真实机器一样运行程序。然而，x86处理器的设计初衷并没有将系统虚拟化考虑在内，当时在大型主机上普遍适用的``陷入并模拟''（Trap-and-Emulate）虚拟化策略在x86体系结构上未能奏效。这是因为如果按照``陷入并模拟''策略让x86虚拟机在较低权限级别运行，某些敏感x86指令会默默地执行失败而不会产生到虚拟机监控器的陷入，即为虚拟化漏洞，例如POPF指令在Ring 3权限级别执行时不会对\%eflags寄存器状态位产生影响也不会触发处理器异常，这便让虚拟机监控器失去了模拟这些敏感指令行为的机会。而Intel出于x86平台的向后兼容性考虑，不可能去改变已发布x86指令集的行为，这个困境在很长一段时间里阻碍了x86平台系统虚拟化的发展。

虽然存在不小的困境，但x86平台上的系统虚拟化还不至于无路可循。一种简单粗暴的解决方法便是``模拟执行''。具体而言，便是分配一个足够大的数组当作虚拟机的内存，根据x86指令集规范，编写一个包含众多case分支的switch语句，获取当前要执行的指令，严格按照指令集规范说明模拟执行。以上``模拟执行''的方法固然可行，但效率不敢恭维，这种虚拟机至少要比真实机器慢上一个数量级。此外，所谓的动态类型语言，如Python、PHP、Ruby，在被编译成中间代码后，大多也是遵循了这种``模拟执行''的方法，因此执行速度相比于编译型语言快不起来。著名的x86模拟器Bochs便是采用了这种``模拟执行''方法，虽然速度慢，但是兼容性良好，而且不容易出现安全漏洞。

除去``模拟执行''，二进制翻译技术也能用于解决x86平台上的系统虚拟化困境，且具备性能上的优势。如今Java、.NET、JavaScript等语言使用的JIT（Just-In-Time）技术也是类似的套路。不能因为指令翻译难实现就因噎废食，一个运行上亿次的for循环，其中如果都是加减之类的数学运算操作，翻译成机器码在处理器上直接执行，肯定比``模拟执行''要快得多。应用到系统虚拟化领域时，在二进制翻译前面，要加上``动态''两个字，也就是在虚拟机执行过程中，碰到能翻译的普通指令区块就翻译成目标架构的机器码直接执行，并缓存起来以便后续重复执行，碰到不能直接翻译的特殊指令区块（某些关乎处理器全局状态的敏感指令，例如更改页表寄存器值的MOV \%CR3指令）就陷入到虚拟机监控器中或调用虚拟机监控器提供的接口，让虚拟机监控器模拟执行敏感指令，接着再继续对后面的虚拟机代码进行翻译。

VMware的工程师们在1998年首先实现了基于动态二进制翻译（Dynamic Binary Translation）的虚拟机监控器，成功在x86平台上实现了系统虚拟化，并推出了VMware Workstation、VMware ESX等商业化产品。Fabrice Bellard完成的Qemu实现原理与上述类似，不过Qemu还支持在x86平台上模拟ARM、MIPS、SPARC、PowerPC等多种处理器架构。VMware针对动态二进制翻译还额外提出了众多功能和细节上的优化，这使得其商业化产品性能良好。VMware在x86系统虚拟化领域的创举，也复苏了研究人员和硬件厂商重新发掘这个领域的热情。

动态二进制翻译虽然已经比``模拟执行''快了许多，但由于为了让每条敏感指令得到模拟执行执行流都要往虚拟机管理器绕一圈（而事实上在大多数情况下执行多条敏感指令仅仅是为了完成某个单一目的，如在使用了PAE分页机制的32位操作系统中修改页表项需要两条MOV指令），这使得虚拟机离真实机器的性能仍然有一定差距。为了提升虚拟机的运行性能，研究人员想到了让虚拟机操作系统辅助配合，即为所谓的``半虚拟化''（Para-virtualization）。``Para''前缀是``with''、``alongside''的意思，也就是说虚拟机与虚拟化层不再是严格的上下级关系，而是互信合作的关系。虚拟机操作系统知道自己正处在虚拟化层之上运行，虚拟化层也要在一定程度上信任虚拟机操作系统。Xen在初始阶段便是一个只支持半虚拟化的虚拟化平台，为x86系统虚拟化领域开启了新的篇章。

既然动态二进制翻译的难点和性能瓶颈在于模拟执行那些各式各样的敏感指令，我们能不能修改虚拟机的操作系统内核，把那些敏感指令改得``好看''一些，即对虚拟化更友好？以上便是半虚拟化技术的中心思想。毕竟在大多数情况下，我们并不需要对虚拟机刻意``隐瞒'' 虚拟化层的存在，而是要在虚拟机之间提供必要的隔离，同时又不造成太多的性能开销。

采用半虚拟化的虚拟机操作系统内核需要经过特殊修改，将原先由敏感指令构成的操作改为对虚拟化层功能接口的调用，即超调用（Hypercall）。在现代操作系统中，由于这些体系结构相关的敏感操作实现都被封装起来了（例如Linux内核源码树中的arch/目录），对比动态二进制翻译需要考虑到各种边界情况，半虚拟化对虚拟机操作系统内核源码的修改就显得要简单一些了。相比于使用了动态二进制翻译的全虚拟化（Full-virtualization），半虚拟化是牺牲了通用性来换取性能，因为任何操作系统都可以无修改地运行在全虚拟化平台上，而每个半虚拟化的操作系统内核都要经过人工仔细修改，且要以能获取其源码为前提。

同样的功能，依靠专用硬件实现几乎总是比软件实现性能更好，这几乎已经成为了一条金科玉律。为了顺应市场对于高性能x86系统虚拟化方案的强烈愿求，Intel和AMD在2005年几乎于相同的时间推出了x86硬件辅助虚拟化（Hardware-assisted Virtualization）解决方案，并在之后的发展历程中不断对其进行了增强。Intel的解决方案叫做Intel VT（Intel Virtualization Technology）或VMX（Virtual Machine Extension），AMD的解决方案被称为SVM（Secure Virtual Machine）。

在硬件上帮助软件系统实现以前难以完美解决的方案并不是一个新概念。早在1974年，Popek和Goldberg便在``Formal requirements for virtualizable third generation architectures''著名论文中提及了可虚拟化体系结构必须满足的三个必要条件：1）虚拟机监控器提供了与真实机器一模一样的虚拟环境；2）运行在虚拟机里的程序在最坏情况下也比物理机慢得不多；3）虚拟机监控器能够完全控制所有的系统资源；3a）虚拟机里的程序不能访问未分配给它的资源，3b）在某些情况下，虚拟机监控器能够回收已经分配给虚拟机的资源。早期的x86指令架构不满足上述条件，因而需要虚拟机监控器进行复杂的动态二进制翻译。既然动态二进制翻译的主要工作在于捕获虚拟机执行中的敏感指令，硬件辅助虚拟化中处理器最重要的角色便是捕获这些关键事件并将其交由虚拟机监控器处理。

为了维持对早期x86程序的兼容性，硬件辅助虚拟化在x86体系结构原有的四个执行特权级（Ring）基础上，增加了一个专供虚拟机监控器使用的与原先特权级别正交的根模式（Root mode），而虚拟机中的操作系统和应用程序处于独立的非根模式（Non-root mode）运行。这样一来，尽管虚拟机操作系统运行在Ring 0，其执行敏感指令时仍然会触发异常并被处理器自动捕获，从而陷入到位于根模式的虚拟机监控器中，待到虚拟机监控器完成处理后再使用VMLAUNCH或VMRESUME指令让执行流返回虚拟机。

下一节将对硬件辅助虚拟化技术进行详细阐述。

\section{硬件辅助虚拟化技术}

\subsection{概述}

硬件辅助虚拟化技术，顾名思义，就是在处理器、芯片组和I/O设备等硬件层面上加入专门针对虚拟化的支持，让虚拟机监控器能够更容易、高效率地实现系统虚拟化。

之所以要在硬件层面给予辅助，原因来自多方面。首先，由于原先x86体系结构存在虚拟化漏洞，单纯的``陷入并模拟''方案是行不通的，而动态二进制翻译技术难以处理虚拟机内的自修改代码和自参考代码，采用半虚拟化技术的前提是能够获取虚拟机内操作系统的源码；其次，由于硬件特性的限制，某些虚拟化功能尽管理论上可以用软件方法实现，但是实现途径异常曲折复杂，一个典型的例子便是限制虚拟机访存的影子页表（Shadow Page Table，SPT），其受限于原先处理器硬件只能提供一层内存地址转化功能；最后，某些使用软件方法实现的虚拟化功能往往性能和隔离性达不到要求，例如网卡磁盘等I/O设备的虚拟化。以上提及的这些问题，只有在处理器、芯片组等硬件层面上提供相应的辅助支持，才能得以完全解决。

两大处理器厂商Intel和AMD都想方设法在系统虚拟化领域中占得先机，但是AMD的虚拟化技术在时间上要比Intel落后几个月。Intel自2005年末开始便在其处理器产品线中推广应用Intel VT(Intel Virtualization Technology）硬件辅助虚拟化技术。

AMD处理器提供的硬件辅助虚拟化技术虽然与Intel VT在细节上存在差异，不过它们的主体架构和核心思想是类似的，下文章节将以Intel VT为例详细介绍硬件辅助虚拟化技术。

\subsection{CPU虚拟化}

Intel VT在x86处理器原有的四个运行权限级别基础上，引入了两种新的操作模式，统称为VMX操作模式。

\begin{itemize}
\item VMX根模式（VMX Root Mode）：虚拟机监控器所处的运行模式，基本等同于加入硬件辅助虚拟化支持以前的处理器工作模式，以下简称根模式。
\item VMX非根模式（VMX Non-Root Mode）：客户虚拟机所处的运行模式，虚拟机中的二进制代码无需经过特殊处理直接以该模式在处理器硬件上直接运行，以下简称非根模式。
\end{itemize}

这两种VMX操作模式与32位x86处理器原有的Ring 0$\sim$Ring 3权限级别是正交的，即在每种VMX操作模式下都有Ring 0$\sim$Ring 3这四个运行权限级别。Intel VT采用这种改动方式的理由很明显，x86体系结构不能借助``陷入并模拟''这种经典方式进行系统虚拟化的根本原因在于其中的19条指令无法在低权限级别产生陷入，从而导致了虚拟化漏洞。如果简单地修改这19条指令的语义，让其在低权限级别运行时也能产生陷入，便会破坏与之前软件代码的二进制兼容性，而这是不可接受的。通过引入新的处理器运行模式，并重新定义敏感指令（包括之前的19条指令）在非根模式下的运行行为，即让其在非根模式运行时也能够产生到根模式的陷入，便能很好地填补先前的虚拟化漏洞。同时，Intel VT保持了x86原先所有指令在根模式下的运行语义不变，因此之前的二进制代码仍能正常运行。Intel VT通过这种途径很好地解决了x86系统虚拟化问题。

虚拟机在支持Intel VT技术的x86处理器上运行过程如下：

\begin{figure}[!htp]
  \centering
  \includegraphics[width=0.7\textwidth]{chap2/mode.png}
  \bicaption[fig:mode]{Intel VT支持下的虚拟机的运行循环}{Intel VT支持下的虚拟机的运行循环}{Fig}{Virtual machine life cycle with Intel VT}
\end{figure}

\begin{enumerate}
\item 虚拟机监控器执行VMXON指令让处理器进入VMX根模式，为运行客户虚拟机做准备。
\item 虚拟机监控器执行VMLAUNCH或者VMRESUME指令产生VM Entry，执行流转移至虚拟机内部的代码，处理器处于VMX非根模式运行。
\item 由于客户虚拟机执行了敏感指令，或者在其运行期间发生了硬件中断或软件异常，VM Exit被触发，执行流重新回到虚拟机监控器，处理器回到VMX根模式运行。
\item 虚拟机监控器根据虚拟化陷入发生的原因进行相应的处理，处理完成后，虚拟机监控器可以选择继续回到先前运行的客户虚拟机或者重新挑选另一个客户虚拟机运行，即回到步骤2。
\item 所有的客户虚拟机运行完毕，虚拟机监控器使用VMXOFF指令让处理器从VMX根模式退出。
\end{enumerate}

以上流程中包含了两个处理器在VMX根模式和VMX非根模式间切换的行为，分别为从根模式切换到非根模式的VM Entry和从非根模式切换到根模式的VM Exit。

\begin{enumerate}
\item VM Entry：虚拟机监控器在VMCS中设置好虚拟机接下来运行的上下文环境，使用VMLAUNCH（用于第一次或刚执行VMCLEAR后的VM Entry）或VMRESUME（用于执行过VMLAUNCH虚拟机的后续VM Entry）使处理器由根模式向非根模式转换，转换完成后，虚拟机内部的代码开始在处理器上直接执行。
\item VM Exit：由于某些原因，如虚拟机执行了敏感指令或发生了外部中断，处理器暂停执行虚拟机内部代码，从非根模式回退至根模式。虚拟机监控器会根据VM Exit发生的具体原因，对应地给予处理，如模拟指令行为等。在硬件辅助虚拟化中，处理VM Exit是虚拟机监控器最主要的职责。
\end{enumerate}

VMCS（Virtual Machine Control Structure）被用于在虚拟机监控器和处理器硬件之间共享虚拟机执行的上下文环境和交换数据信息。虚拟机监控器可以通过修改VMCS中的某些位域来控制虚拟机在非根模式下的运行行为，在VM Exit发生时虚拟机监控器可以从VMCS中获取陷入发生的具体原因，此外虚拟机某些关键寄存器的值在VM Exit和VM Entry发生时会在VMCS中进行保存和恢复。VMCS占用一个对齐的4KB大小的内存区域，即一个普通内存页框，其中主要的结构组成如下：

\begin{enumerate}
\item 客户虚拟机状态域，如虚拟机部分关键寄存器的值、虚拟处理器可中断状态。
\item 宿主机状态域，主要是宿主机部分关键寄存器的值。
\item 虚拟机执行控制域，控制客户虚拟机在非根模式下的执行行为。
\item 虚拟化陷入控制域，控制虚拟化陷入的产生条件。
\item 虚拟机进入控制域，控制处理器从根模式向非根模式转换
\item 虚拟化陷入信息域
\end{enumerate}

VMCS结构、新指令

\subsection{内存虚拟化}

\subsection{中断虚拟化}

\section{本章小结}

